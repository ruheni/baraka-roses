### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Agent {
  createdAt: DateTime!
  Customer: Customer
  email: String!
  id: Int!
  name: String!
  phoneNumber: String!
}

input AgentListRelationFilter {
  every: AgentWhereInput
  none: AgentWhereInput
  some: AgentWhereInput
}

input AgentOrderByInput {
  createdAt: SortOrder
  customerId: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  phoneNumber: SortOrder
}

input AgentWhereInput {
  AND: [AgentWhereInput!]
  createdAt: DateTimeFilter
  Customer: CustomerWhereInput
  customerId: IntNullableFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AgentWhereInput!]
  OR: [AgentWhereInput!]
  phoneNumber: StringFilter
}

input AgentWhereUniqueInput {
  email: String
  id: Int
}

type AuthPayload {
  token: String
  User: User
}

"""Flower colors"""
enum Color {
  BI_COLOUR
  CERISE
  LILAC
  ORANGE
  PEACH
  PINK
  RED
  WHITE
  YELLOW
}

type Customer {
  agents(after: AgentWhereUniqueInput, before: AgentWhereUniqueInput, first: Int, last: Int, orderBy: [AgentOrderByInput!], where: AgentWhereInput): [Agent!]!
  contactName: String!
  createdAt: DateTime!
  email: String!
  id: Int!
  market: String!
  name: String!
  orders(orderBy: [OrderOrderByInput!], where: OrderWhereInput): [Order!]!
  phoneNumber: String!
}

input CustomerWhereInput {
  agents: AgentListRelationFilter
  AND: [CustomerWhereInput!]
  contactName: StringFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  market: StringFilter
  name: StringFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  orders: OrderListRelationFilter
  phoneNumber: StringFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

"""Flower grades"""
enum Grade {
  GRADED
  UNGRADED
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createAgent(customerId: Int!, email: String!, name: String!, phoneNumber: String!): Agent
  createCustomer(agentIds: [Int!]!, contactName: String!, email: String!, market: String!, name: String!, phoneNumber: String!): Customer!
  createOrder(customerId: Int!, date: String!, productIds: [Int!]!): Order
  createProduct(color: Color!, grade: Grade!, length: Int!, quantity: Int!, variety: String!): Product
  login(email: String!, password: String!): AuthPayload
  signup(email: String!, firstName: String!, lastName: String!, password: String!, role: Role!): AuthPayload
  updateAgent(email: String!, id: Int!, name: String!, phoneNumber: String!): Agent!
  updateCustomer(contactName: String!, email: String!, id: Int!, market: String!, name: String!, phoneNumber: String!): Customer!
  updateOrder(finalQuantity: Int!, id: Int!, productIds: Int, status: OrderStatus!): Order
  updateProduct(color: Color!, grade: Grade!, id: Int!, length: Int!, quantity: Int!, variety: String!): Product
  updateUser(email: String!, firstName: String!, id: Int!, lastName: String!, password: String!, role: Role!): User
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Order {
  createdAt: DateTime!
  Customer: Customer
  date: DateTime!
  id: Int!
  orderedProducts(after: OrderedProductWhereUniqueInput, before: OrderedProductWhereUniqueInput, first: Int, last: Int): [OrderedProduct!]!
  status: OrderStatus!
}

type OrderedProduct {
  finalQuantity: Int!
  id: Int!
  initialQuantity: Int!
  product: Product!
}

input OrderedProductListRelationFilter {
  every: OrderedProductWhereInput
  none: OrderedProductWhereInput
  some: OrderedProductWhereInput
}

input OrderedProductWhereInput {
  AND: [OrderedProductWhereInput!]
  finalQuantity: IntFilter
  id: IntFilter
  initialQuantity: IntFilter
  NOT: [OrderedProductWhereInput!]
  OR: [OrderedProductWhereInput!]
  Order: OrderWhereInput
  orderId: IntNullableFilter
  product: ProductWhereInput
  productId: IntFilter
}

input OrderedProductWhereUniqueInput {
  id: Int
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

input OrderOrderByInput {
  createdAt: SortOrder
  customerId: SortOrder
  date: SortOrder
  id: SortOrder
  status: SortOrder
}

"""Order statuses"""
enum OrderStatus {
  CANCELLED
  PENDING
  REVIEWED
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  createdAt: DateTimeFilter
  Customer: CustomerWhereInput
  customerId: IntNullableFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  orderedProducts: OrderedProductListRelationFilter
  Product: ProductListRelationFilter
  status: OrderStatus
}

type Product {
  color: Color!
  createdAt: DateTime!
  grade: Grade!
  id: Int!
  length: Int!
  quantity: Int!
  variety: String!
}

input ProductListRelationFilter {
  every: ProductWhereInput
  none: ProductWhereInput
  some: ProductWhereInput
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  color: Color
  createdAt: DateTimeFilter
  grade: Grade
  id: IntFilter
  length: IntFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  Order: OrderWhereInput
  OrderedProduct: OrderedProductListRelationFilter
  orderId: IntNullableFilter
  quantity: IntFilter
  variety: StringFilter
}

type Query {
  agentProfile(id: Int!): Agent
  agents: [Agent!]!
  customerProfile(id: Int!): Customer
  customers: [Customer!]!
  findOrdersByStatus(status: OrderStatus!): [Order!]
  orderDetails(id: Int!): Order
  orders: [Order!]!
  productDetails(id: Int!): Product
  products: [Product!]!
  userProfile(email: String!): User
  users: [User!]!
}

"""These are the different roles supported on the platform"""
enum Role {
  ADMIN
  GENERAL_MANAGER
  SALES_EXEC
  STOCK_CLERK
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type User {
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: Int!
  lastName: String!
  password: String!
  role: Role!
}
